scTSS is a package that can leverage the 5’ single-cell RNA-seq data to
study the transcription start site (TSS) at single-cell resolution.
scTSS comprises of two main stages, TSS prediction and differential TSS
usage (DU) test for TSSs across two or multiple conditions or cell
types.

To download scTSS from github and load package, please follow:

``` r
devtools::install_github("https://github.com/ShweiSTAT/scTSS")
library(scTSS)
```

The example data for this tutorial can be downloaded from this
[link](https://www.dropbox.com/scl/fo/6m2xepe4wrleq5yl59w3h/AP8qu3d_1FVUKuHvxMrO9pg?rlkey=5u3h6qfsw4894x3z78ihapuad&st=g7yds674&dl=0).
In this example, we have 5 samples (blood from 5 different human) with
TSS clusters predicted based on paired-end 5’ single-cell RNA-seq data.
Our final goal is to detect differential TSS cluster usage between the B
and Activated T cells across the 5 samples.

# Preprocessing

For the paired-end data, the preprocessing starts with the raw reads
(**.fastq** files) from 5’ single-cell RNA-seq experiments. The reads
should be aligned to reference genome by an alignment tool for
single-cell RNA sequencing data. We assume this alignment is performed
sample by sample. For example, for the reads generated by 10x Genomics
5’ Gene Expression assay, we use Cell Ranger to perform alignment for
each one of the samples. At the end of the alignment step, we obtain the
aligned **.bam** file and the corresponding **.bai** file for each
sample.

# Predicting TSS clusters for a sample

The paired-end 5’ single-cell RNA-seq data contains both read 1 and read
2. The read 1 contains the direct information of the transcription start
site (TSS), thus we call the paired-end data as “on-site” data. Most of
the already available TSS analysis tools are capable of predicting TSS
clusters based on the mapped genomic positions of the 5’ of the read 1.
Thus, scTSS will rely on the existing tools to predict TSS clusters for
each sample. ![Paired-end
data](pairedEndDemo.pdf)

After the preprocessing step, we need to use the **.bam** files to
obtain predictions for TSS clusters by a bioinformatics tool compatible
with. We recommend using SCAFE. Please refer to this
[link](https://github.com/chung-lab/SCAFE) for details. After running
SCAFE (or any other TSS prediction tools of choice), we should obtain a
prediction of TSS clusters for each sample. As for SCAFE, the predicted
TSS clusters are stored in a **.bed** file, please refer to this
[file](https://www.dropbox.com/scl/fi/hhri3bfxc1tt35jz9ag52/example_SCAFE_clusters.bed?rlkey=u6ztyzfzxmch67eq6ih0qdpa1&st=w1x3l88t&dl=0)
as an example.

No matter what TSS cluster prediction tools used, we need to at least
obtain these pieces of information for each sample:

    - seqnames: the chromosome where the TSS cluster located;
    - start: the start location (on genome) of the TSS cluster;
    - end: the end location (on genome) of the TSS cluster;
    - strand: the strand that the TSS cluster is on.

For the SCAFE output, these information are stored in columns “V1”
(seqnames), “V2” (start), “V3” (end) and “V5” (strand).

``` r
TSS_clsuterEg <- read.delim("example_SCAFE_clusters.bed",
                             header = 0)
head(TSS_clsuterEg)
```

    #>     V1     V2     V3                   V4  V5 V6     V7     V8         V9 V10
    #> 1 chr1  11823  11947   chr1_11823_11947_+  11  +  11853  11854  227,26,28   1
    #> 2 chr1  29192  29375   chr1_29192_29375_- 708  -  29358  29359 31,120,180   1
    #> 3 chr1  96637  96807   chr1_96637_96807_+  13  +  96709  96710  227,26,28   1
    #> 4 chr1 181092 181161 chr1_181092_181161_-   8  - 181140 181141 31,120,180   1
    #> 5 chr1 182322 182391 chr1_182322_182391_+  20  + 182372 182373  227,26,28   1
    #> 6 chr1 195410 195431 chr1_195410_195431_-  21  - 195430 195431 31,120,180   1
    #>   V11 V12
    #> 1 124   0
    #> 2 183   0
    #> 3 170   0
    #> 4  69   0
    #> 5  69   0
    #> 6  21   0

# Merging TSS clusters for multiple samples

Due to technical effects during the sequencing or mapping procedures,
the TSS clusters predicted on each single sample might be a few base
pairs different, even if they might refer to the exact same promoter (or
TSS cluster). Thus, merging TSS clusters from multiple samples to obtain
a unified TSS clusters is necessary for downstream multiple sample
analysis.

TSS cluster merging is achieved by function `mergeTSS`. The major
parameter of `mergeTSS` is

-   `unmerged_TSS_cluster_list`, a `list` of `data.frames`. Every single
    `data.frame` within this list is the unmerged TSS cluster
    predictions for a sample. Each `data.frame` should contain columns
    listed below with the exact column names:

    -   seqnames: the chromosome where the TSS cluster located;
    -   start: the start location (on genome) of the TSS cluster;
    -   end: the end location (on genome) of the TSS cluster;
    -   strand: the strand that the TSS cluster is on.

Within the `mergeTSS` function, we also need to pay attention to these
parameters:

-   `if_paired`, TRUE/FALSE and specifies if the data is paired-end
    (TRUE) or single-end (FALSE). The default is TRUE;
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

In the following example, we have the unmerged TSS clusters predicted on
the 5 samples separately. The unmerged TSS clusters are stored in an
object named `unmerged_TSS_clusters`, which is a `list` object. Within
this `list`, the TSS cluster predictions are stored in 5 different
`data.frame`. Each `data.frame` is corresponding to a sample.

``` r
# read in the list of unmerged TSS clusters for 5 samples
unmerged_TSS_clusters <- readRDS("unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample1
head(unmerged_TSS_clusters$Sample1)
```

    #>   seqnames    start      end strand
    #> 1    chr21 41879296 41879491      -
    #> 2    chr21 44300021 44300103      +
    #> 3    chr21 45981721 45981770      +
    #> 4    chr21 33324383 33324506      +
    #> 5    chr21 33324894 33325021      +
    #> 6    chr21 33325025 33325124      +

An example for merging TSS clusters is shown below.

``` r
# perform TSS merging
mergedTSS_clusters <- mergeTSS(unmerged_TSS_cluster_list = unmerged_TSS_clusters,
                               if_paired = TRUE,
                               ncore = 1)
```

For paired-end data, the `mergeTSS` returns a single `data.frame` for
the merged TSS clusters across all the samples.

``` r
# example for merged TSS clusters
head(mergedTSS_clusters)
#>   seqnames    start      end strand
#> 1    chr21 17512989 17513002      +
#> 2    chr21 17513003 17513014      +
#> 3    chr21 17513015 17513096      +
#> 4    chr21 17513097 17513106      +
#> 5    chr21 17513107 17513109      +
#> 6    chr21 17513110 17513118      +
```

# Qauntifing the expression for TSS clusters

After obtaining the merged TSS clusters, we need to quantify the
single-cell TSS cluster expression (counts) sample by sample, which is
achieved by function `quantifyTSS`.

The must-have input arguments for `quantifyTSS` are

-   `anno_path`, the path to the genome annotation file, which should be
    in the **.gtf** format;
-   `bam_path`, the path to the aligned **.bam** file of the sample.
    Noting that the corresponding **.bai** file should be stored under
    the same directory;
-   `tss_clusters`, a `data.frame` specifies the TSS clusters to be
    quantified. For paired-end data, these columns should be included:
    seqnames, start, end and strand;
-   `cell_meta`, a data.frame specifies the meta information for each
    cell. “barcode” and “sampleID” must be included as columns.
    “barcode” specifies the barcodes for each of the cells to be
    quantified in this sample; “sampleID” is a unique ID for each
    sample. To make downstream analysis easier, other related variables
    are also suggested to be included in this `data.frame` as well, such
    as cell types or the sample’s demographic information (age, gender,
    etc.).

These are the other parameters that also control the behaviors of
`quantifyTSS`:

-   `gene_of_interest`, a vector of characters and specifies the genes
    for which the TSS quantification should be performed. The default is
    set to `NULL`, which means all the genes in the **.gtf** file are
    considered. The input gene names should be compatible to the
    **.gtf** file;
-   `read_number`, an integer specifying the minim number of reads that
    should be assigned to a valid TSS clusters within this sample. This
    is used to filter out lowly expressed TSS clusters. Defaults to 50.
-   `reads_percentage`, a percentage specifying the minim percentage of
    reads on a gene that should be assigned to a valid TSS clusters
    within this sample. This is used to filter out lowly expressed TSS
    clusters. Defaults to 0.05.
-   `if_paired`, TRUE/FALSE and specifies if the data is paired-end
    (TRUE) or single-end (FALSE). The default is TRUE;
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

In the following example, we use the merged TSS clusters from the 5
samples as the input `tss_clusters` to be quantified. Since the TSS
cluster quantification is repetitive for all the 5 samples, we only show
an example for “Sample1”. The cell meta data for Sample1 is stored in an
object named `sample1_meta`.

``` r
# read in the cell_meta for Sample1
sample1_meta <- readRDS("Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```

    #>              barcode sampleID  cell_type
    #> 1 AAACCTGAGAGTGAGA-1  Sample1 CD14+ Mono
    #> 2 AAACCTGAGCCACCTG-1  Sample1 CD14+ Mono
    #> 3 AAACCTGCACATGTGT-1  Sample1 CD14+ Mono
    #> 4 AAACGGGCAAAGGCGT-1  Sample1 CD14+ Mono
    #> 5 AAACGGGTCACCAGGC-1  Sample1 CD14+ Mono
    #> 6 AAACGGGTCTTGTACT-1  Sample1 CD14+ Mono

An example for quantifying TSS clusters for Sample1 is shown below.

``` r
# Quantify TSS clusters' expression for Sample1

example_genes <- c("ENSG00000141956","ENSG00000141959",
                   "ENSG00000142156","ENSG00000142166",
                   "ENSG00000142168","ENSG00000142173",
                   "ENSG00000142178","ENSG00000142185",
                   "ENSG00000142188","ENSG00000142192",
                   "ENSG00000142197","ENSG00000142207",
                   "ENSG00000154639","ENSG00000154640",
                   "ENSG00000154642")


Sample1_quantified <- quantifyTSS(anno_path = "example.gtf",
                                  bam_path = "Sample1_sorted.bam",
                                  tss_clusters = mergedTSS_clusters,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = TRUE,
                                  ncore = 1 )
```

    #> [1] "Start quantifing 127 clusters on 15 genes"
    #> [1] "Counting reads finished!"

`quantifyTSS` outputs a list which contains two objects. 1)
`TSS_cluster_counts`, a `data.table` for the expression (counts) of each
TSS clusters at cell level. 2) `Column_meta`, a `data.frame` containing
the meta information for each of the columns (cells) in
`TSS_cluster_counts`. The columns in TSS_cluster_counts and the rows in
`Column_meta` have one on one correspondence.

In the `TSS_cluster_counts`,each TSS clusters being quantified is given
a unique name, which is coded as
\[chromosome\]:\[gene\]:\[start\]:\[end\]:\[strand\]. For example
chr21:ENSG00000141956:41879301:41879351:-.

``` r
# example of the TSS quantification output for Sample1

## TSS cluster counts
head(Sample1_quantified$TSS_clsuter_counts[,1:3])
#>                                 TSS_clusters Sample1_AAACCTGAGAGTGAGA-1
#>                                       <char>                      <int>
#> 1: chr21:ENSG00000141956:41879301:41879351:-                          0
#> 2: chr21:ENSG00000141959:44300021:44300103:+                          0
#> 3: chr21:ENSG00000142156:45981733:45981770:+                          0
#> 4: chr21:ENSG00000142166:33324407:33324451:+                          0
#> 5: chr21:ENSG00000142166:33324903:33324990:+                          0
#> 6: chr21:ENSG00000142166:33324992:33325014:+                          0
#>    Sample1_AAACCTGAGCCACCTG-1
#>                         <int>
#> 1:                          0
#> 2:                          0
#> 3:                          0
#> 4:                          0
#> 5:                          5
#> 6:                          0

## column meta for TSS cluster counts
head(Sample1_quantified$Column_meta)
#>                      barcode sampleID  cell_type
#> 1 Sample1_AAACCTGAGAGTGAGA-1  Sample1 CD14+ Mono
#> 2 Sample1_AAACCTGAGCCACCTG-1  Sample1 CD14+ Mono
#> 3 Sample1_AAACCTGCACATGTGT-1  Sample1 CD14+ Mono
#> 4 Sample1_AAACGGGCAAAGGCGT-1  Sample1 CD14+ Mono
#> 5 Sample1_AAACGGGTCACCAGGC-1  Sample1 CD14+ Mono
#> 6 Sample1_AAACGGGTCTTGTACT-1  Sample1 CD14+ Mono
```

# Differential TSS usage (DU) test

In the **scTSS** package, we implemented a binomial generalized linear
mixed model (GLMM) to test the differential TSS usage between conditions
while controlling the sample level variability. For more detailed
formulation, please check our paper.

Suppose we have quantified all the 5 samples beforehand and the
quantification output can be found under the folder
`TSS_quantification_outs` within the example data folder.

In the chunk below, we read in the quantification results for the 5
example samples and store them in an object called
`Quantified_TSS_clusters`, which is a `list`.

``` r
# read in quantification results
Sample1 <- readRDS("TSS_quantification_outs/Sample1_quant_outs.rds")
Sample2 <- readRDS("TSS_quantification_outs/Sample2_quant_outs.rds")
Sample3 <- readRDS("TSS_quantification_outs/Sample3_quant_outs.rds")
Sample4 <- readRDS("TSS_quantification_outs/Sample4_quant_outs.rds")
Sample5 <- readRDS("TSS_quantification_outs/Sample5_quant_outs.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5)
```

## Preparation

Before running the DU test, we need to prepare the quantification
output. The preparation usually consists of two parts:

-   Prepare the joint TSS cluster count matrix (of `matrix` format in R)
    for multiple samples, which can usually be broken down into these
    steps:

    -   Merge TSS cluster count matrices for multiple samples;
    -   Remove lowly expressed TSS clusters;
    -   Remove genes that only have only one TSS clusters (If a gene has
        only one TSS clusters expressed, the usage of this TSS cluster
        will remain 100% between cell types or conditions no matter
        what).

-   Prepare the column (cell) meta data (of `data.frame` format) that is
    corresponding to the joint TSS cluster count matrix.

To make the preparation easier, we include a function named
`SetMatrixNameSame` to provide an all-in-one solution.
`SetMatrixNameSame` has these important argument for input:

-   `Quantified_TSS_list`, a `list` of the outputs from the
    `quantifyTSS` function. Each element of the list is a single output.

There are other argument to control the behavior of `SetMatrixNameSame`:

-   `exp_level`, a percentage. Within every sample (specified by
    “sampleID” in the column meta data), a valid TSS cluster should be
    expressed in more than this percentage of cells. Default is 0,
    indicating any TSS clusters that are not expressed in all sample
    will be removed.

Since we are only interested in the B cells and Activated T cells,
before we can run `SetMatrixNameSame`, we need to filter out all other
cells for each sample. The example code is shown below.

``` r
# select only B cells and Activated T cells
for(i in 1:length(quantified_TSS_clusters)){
  temp_sample <- quantified_TSS_clusters[[i]]
  temp_Column_meta <- temp_sample$Column_meta
  temp_TSS_cluster_counts <- temp_sample$TSS_cluster_counts
  
  ## select the barcode for B cells and Activated T cells
  selected_barcode <- with(temp_Column_meta,
                           barcode[cell_type%in%c("B","Activated T")])
  
  ## filter both Column_meta and TSS_cluster_counts
  rows_selected <- which(temp_Column_meta$barcode%in%selected_barcode)
  temp_Column_meta <- temp_Column_meta[rows_selected,]
  
  cols_selected <- c("TSS_clusters",selected_barcode)
  temp_TSS_cluster_counts <- temp_TSS_cluster_counts[ , ..cols_selected]

  
  temp_sample$Column_meta <- temp_Column_meta
  temp_sample$TSS_cluster_counts <- temp_TSS_cluster_counts
  
  quantified_TSS_clusters[[i]] <- temp_sample
  }

# running SetMatrixNameSame
DU_input <- SetMatrixNameSame(Quantified_TSS_list = quantified_TSS_clusters,
                              exp_level = 0)
#> [1] "In sample Sample1 513 TSS clusters were delected for low expression."
#> [1] "In sample Sample2 581 TSS clusters were delected for low expression."
#> [1] "In sample Sample3 568 TSS clusters were delected for low expression."
#> [1] "In sample Sample4 529 TSS clusters were delected for low expression."
#> [1] "In sample Sample5 491 TSS clusters were delected for low expression."
#> [1] "887 TSS clusters were delected for being the single TSS cluster on gene."
#> [1] "632 TSS clsuters on 274 genes are in the final output."
```

`SetMatrixNameSame` returns a list containing these two elements:

-   `TSS_count_matrix`, a `data.matrix` object specifying the TSS
    cluster counts matrix ready for DU test;
-   `col_meta`, a column meta `data.frame` compatible with
    `TSS_count_matrix`, which is ready for DU test.

An example for the output is shown below

``` r
# TSS_count_matrix
head(DU_input$TSS_count_matrix[,1:3])
#>                                            Sample1_GCACTCTGTAACGCGA-1
#> chr1:ENSG00000000460:169662003:169662005:+                          0
#> chr1:ENSG00000000460:169683374:169683390:+                          0
#> chr1:ENSG00000000460:169795042:169795088:+                          0
#> chr1:ENSG00000001461:24415769:24415813:+                            0
#> chr1:ENSG00000001461:24415815:24415889:+                            0
#> chr1:ENSG00000007341:112619117:112619127:-                          0
#>                                            Sample1_GCAGTTACAGGCTGAA-1
#> chr1:ENSG00000000460:169662003:169662005:+                          0
#> chr1:ENSG00000000460:169683374:169683390:+                          0
#> chr1:ENSG00000000460:169795042:169795088:+                          0
#> chr1:ENSG00000001461:24415769:24415813:+                            0
#> chr1:ENSG00000001461:24415815:24415889:+                            0
#> chr1:ENSG00000007341:112619117:112619127:-                          0
#>                                            Sample1_GCATACATCACGGTTA-1
#> chr1:ENSG00000000460:169662003:169662005:+                          0
#> chr1:ENSG00000000460:169683374:169683390:+                          0
#> chr1:ENSG00000000460:169795042:169795088:+                          0
#> chr1:ENSG00000001461:24415769:24415813:+                            0
#> chr1:ENSG00000001461:24415815:24415889:+                            0
#> chr1:ENSG00000007341:112619117:112619127:-                          0

# col_meta
head(DU_input$col_meta)
#>                      barcode sampleID   cell_type
#> 1 Sample1_GCACTCTGTAACGCGA-1  Sample1 Activated T
#> 2 Sample1_GCAGTTACAGGCTGAA-1  Sample1 Activated T
#> 3 Sample1_GCATACATCACGGTTA-1  Sample1 Activated T
#> 4 Sample1_GCATACATCTTTAGTC-1  Sample1 Activated T
#> 5 Sample1_GCATGTATCTTCATGT-1  Sample1 Activated T
#> 6 Sample1_GCTCTGTGTGTTAAGA-1  Sample1 Activated T
```

#### DU test

After we have obtained the prepared TSS cluster count matrix and the
column meta data, we can conduct DU test. We wrapped the DU test
functionality into function `DUtest`. This function has these must-have
arguments:

-   `mat`, `data.matrix` for the count matrix of TSS clusters. The rows
    are TSS clusters and the columns are cells;
-   `col_meta`, a data.frame containing the column meta information for
    “mat”. It has to contain at least these columns: “barcode”,
    “sampleID”, “condition”.

In the example data, our goal is to test the differential TSS cluster
usage between B and Activated T cells among the blood sample from 5
human. Thus, the “condition” in this example is the “cell_type” column.
To accommodate this difference, we only need to change the column names
for `col_meta` accordingly.

``` r
input_mat <- DU_input$TSS_count_matrix
input_colMeta <- DU_input$col_meta
colnames(input_colMeta)[3] <- "condition"

head(input_colMeta)
#>                      barcode sampleID   condition
#> 1 Sample1_GCACTCTGTAACGCGA-1  Sample1 Activated T
#> 2 Sample1_GCAGTTACAGGCTGAA-1  Sample1 Activated T
#> 3 Sample1_GCATACATCACGGTTA-1  Sample1 Activated T
#> 4 Sample1_GCATACATCTTTAGTC-1  Sample1 Activated T
#> 5 Sample1_GCATGTATCTTCATGT-1  Sample1 Activated T
#> 6 Sample1_GCTCTGTGTGTTAAGA-1  Sample1 Activated T
```

Other important arguments are:

-   `agg_level`, a string to specify the DU test model (“bulk” or
    “cell”). “cell” means the DU test is conducted at single-cell level,
    “bulk” means the DU test is conducted at the pseudo-bulk level. The
    default is “bulk.”
-   `full_model`, the `formula` for the full model. The default is
    cbind(TSS_counts,gene_counts - TSS_counts) ~ condition +
    (1\|sampleID).
-   `base_model`, the `formula` for the base model. The default is
    cbind(TSS_counts,gene_counts - TSS_counts) ~ (1\|sampleID).
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

The example code is shown below.

``` r
outs <- DUtest(mat = input_mat,
               col_meta = input_colMeta,
               agg_level = "bulk",
               full_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID),
               base_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID),
               ncore = 1)
#> [1] "Start running DU test."
#> [1] "Done!"
```

The `DUtest` outputs a `data.frame` containing the *p*-values and other
statistics:

-   “gene_exp_level”, the number of cells having the gene expressed;
-   “TSS_exp_level”, the number of cells having the TSS cluster
    expressed;
-   “max_usage_con”, the condition that has the maximum average TSS
    usage;
-   “max_usage”, the average TSS cluster usage for the condition that
    has the maximum average TSS usage.
-   “min_usage_con”, the condition that has the minimum average TSS
    usage.
-   “min_usage”, the average TSS usage for the condition that has the
    minimum average TSS usage.
-   “pval_adj”, the adjusted *p*-values by Benjamini-Hochberg procedure.

A part of the result is shown below.

``` r
head(outs)
#>                                    TSS_names gene_exp_level TSS_exp_level
#> 1 chr1:ENSG00000000460:169662003:169662005:+             40            10
#> 2 chr1:ENSG00000000460:169683374:169683390:+             40            13
#> 3 chr1:ENSG00000000460:169795042:169795088:+             40            18
#> 4   chr1:ENSG00000001461:24415769:24415813:+            200           168
#> 5   chr1:ENSG00000001461:24415815:24415889:+            200            35
#> 6 chr1:ENSG00000007341:112619117:112619127:-             96            47
#>           pval max_usage_con max_usage min_usage_con min_usage     pval_adj
#> 1 6.145880e-02             B 0.2180451   Activated T 0.1295337 8.171484e-02
#> 2 2.556673e-02   Activated T 0.4870466             B 0.3684211 3.608730e-02
#> 3 4.709969e-01             B 0.4135338   Activated T 0.3834197 5.210668e-01
#> 4 2.710881e-02             B 0.8632812   Activated T 0.8041841 3.808880e-02
#> 5 2.710881e-02   Activated T 0.1958159             B 0.1367188 3.808880e-02
#> 6 1.012793e-08             B 0.5724138   Activated T 0.3771107 2.801149e-08
```
