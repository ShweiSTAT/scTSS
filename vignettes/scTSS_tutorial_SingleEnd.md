scTSS is a package that can leverage the 5’ single-cell RNA-seq data to
study the transcription start site (TSS) at single-cell resolution.
scTSS comprises of two main stages, TSS prediction and differential TSS
usage (DU) test for TSSs across two or multiple conditions or cell
types.

To download scTSS from github and load package, please follow:

``` r
devtools::install_github("https://github.com/ShweiSTAT/scTSS")
library(scTSS)
```

The example data for this tutorial can be downloaded from this
[link](https://www.dropbox.com/scl/fo/6m2xepe4wrleq5yl59w3h/AP8qu3d_1FVUKuHvxMrO9pg?rlkey=5u3h6qfsw4894x3z78ihapuad&st=g7yds674&dl=0).
In this example, we have 6 samples (blood from 6 different human).
Sample 1, 2 and 3 are healthy individuals, while Sample 4, 5, 6 are
patients with a certain type of leukemia. All the blood samples are
sequenced by 10X Genomics single-end 5’ single-cell RNA-seq. Our final
goal is to detect differential TSS cluster usage of CD8 cells between
these two groups of samples

# Preprocessing

For the single-end data, the preprocessing starts with the raw reads
(**.fastq** files) from 5’ single-cell RNA-seq experiments. The reads
should be aligned to reference genome by an alignment tool for
single-cell RNA sequencing data. We assume this alignment is performed
sample by sample. For example, for the reads generated by 10x Genomics
5’ Gene Expression assay, we use Cell Ranger to perform alignment for
each one of the samples. At the end of the alignment step, we obtain the
aligned **.bam** file and the corresponding **.bai** file for each
sample.

# Predicting TSS clusters for sample by sample

The single-end 5’ single-cell RNA-seq data contains only read 2. The
read 2 does not directly capture the location of TSS. However, the
position of read 2 follows a relation with the genuine TSS, which is
related to the length of cDNA.

<figure>
<img
src="/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/SingleEndDemo.png"
alt="Single-end data" />
<figcaption aria-hidden="true">Single-end data</figcaption>
</figure>

We call the single-end data as “near-site” data. Most of the already
available TSS analysis tools are only compatible with the paired-end (or
“on-site”) data. Nevertheless, we can utilize the existing tools to
generate near-site genomic clusters based on the 5’ of read 2, and scTSS
incorporates a method to adjust the near-site genomic clusters to
approximate the genuine locations of TSS clusters (promoters). Since the
TSS cluster prediction is repetitive for every sample, we use a subset
of Sample 1 as an example for this section.

## Generating near-site genomic clusters

After the preprocessing step, we need to use the **.bam** files to
predict near-site genomic clusters. We recommend using TSSr. Please
refer this [link](https://github.com/Linlab-slu/TSSr) for more detailed
information. For TSSr and other TSS analysis tools, they require an
input named CTSS (Capped TSS) table or TSS table for TSS clustering.
This table is generated by mapping the 5’ of Read 1 to the reference
genome for paired-end data. Since the single-end data do not have direct
TSS information and we need to map the 5’ of read 2 onto the genome to
generate near-site clusters, we call this table as “mapped TSS table”,
which usually contains these four columns:

    - seqnames: the chromosome where the TSS cluster located;
    - tss(pos): the mapped location (on genome) of the 5' of Read 2 for single-end data; the mapped location (on genome) of the 5' of Read 1 for paired-end data;
    - strand: the strand of the mapped location on genome;
    - counts: the frequency of reads mapped to this location.

In scTSS, we incorporate a function named `makeMappedTSS` to facilitate
near-site genomic clusters prediction and output mapped TSS table based
on the aligned **.bam** file. `makeMappedTSS` requires these necessary
inputs:

-   `anno_path`, the path to the genome annotation file, which should be
    in the **.gtf** format;
-   `bam_path`, the path to the **.bam**, which should be stored under
    the same directory as its **.bai** file.
-   `if_paired`, FALSE/TRUE and specifies if we have paired-end
    (on-site) data (TRUE) or single- end (near-site) data (FALSE).
    Default set to TRUE.

There are other important input that can control the behavior of
`makeMappedTSS`:

-   `gene_of_interest`, a vector of characters and specifies the genes
    for which the `makeMappedTSS` function should be performed. The
    default is set to `NULL`, which means all the genes in the **.gtf**
    file are considered. The input gene names should be compatible to
    the **.gtf** file;
-   `ncore`, an integer specifying the number of cores used for
    computation. Defaults to 1.

An example code for Sample 1 is shown below:

``` r
## make mapped TSS table
mappedTSS_Sample1 <- makeMappedTSS(anno_path = "example_genes.gtf",
                                   bam_path = "Sample1_sorted.bam",
                                   gene_of_interest = NULL,
                                   if_paired = FALSE,
                                   ncore = 1)
```

The mapped TSS table is stored in a `data.frame.` An example for mapped
TSS table is shown below.

``` r
head(mappedTSS_Sample1)
```

    ##   seqnames      tss strand counts
    ## 1     chr6 26234386      -      2
    ## 2     chr6 26234387      -      1
    ## 3     chr6 26234417      -      2
    ## 4     chr6 26234446      -      1
    ## 5     chr6 26234448      -      1
    ## 6     chr6 26234457      -      2

After we have obtained the Mapped TSS table, we can utilize the TSSr or
other TSS clustering tools to obtain the near-site clusters. For the
near-site clusters, we need to at least obtain these pieces of
information for each sample:

    - seqnames: the chromosome where the near-site cluster located;
    - start: the start location (on genome) of the near-site cluster;
    - end: the end location (on genome) of the near-site cluster;
    - strand: the strand that the near-site cluster is on.

For the TSSr output, these information are stored in columns “chr”
(seqnames), “start”, “end” and “strand.” An example output from TSSr is
shown below.

``` r
NearSite_clsuter_Sample1 <- readRDS("TSSr_output_example.rds")
head(NearSite_clsuter_Sample1)
```

    ##    cluster        chr   start     end strand dominant_tss      tags
    ##      <int>     <char>   <int>   <int> <char>        <int>     <num>
    ## 1:       1 KI270721.1    6094    6214      +         6183 40.648820
    ## 2:       2 KI270721.1    7322    7402      +         7322 50.285071
    ## 3:       3 KI270721.1    7976    8046      +         7976 20.032339
    ## 4:       4 KI270721.1   11450   11483      +        11451  1.058497
    ## 5:       5       chr1 1013493 1013574      +      1013565 20.787776
    ## 6:       6       chr1 1013622 1013733      +      1013691  1.119986
    ##    tags.dominant_tss   q_0.1   q_0.9 interquantile_width
    ##                <num>   <int>   <int>               <num>
    ## 1:          2.143341    6136    6208                  73
    ## 2:          2.745058    7327    7391                  65
    ## 3:          1.822718    7978    8026                  49
    ## 4:          0.136155   11450   11475                  26
    ## 5:          1.475743 1013522 1013572                  51
    ## 6:          0.114194 1013631 1013730                 100

## Adjusting near-site genomic clusters

After we have obtain the near-site genomic clusters for a sample, we
need to adjust them to approximate the genuine locations of TSS
clusters. scTSS provides function `adjustTSS` to achieve this goal.
`adjustTSS` needs these must-have inputs:

-   `anno_path`, the path to the genome annotation file, which should be
    in the **.gtf** format;
-   `clusters`, a `data.frame` containing the near-site clusters to be
    adjusted. The required columns are “seqnames”, “start”, “end”,
    “strand”;
-   `mappedTSS`, a data.frame containing the mapped TSSs based on the
    corresponding single-end data. The required columns are “seqnames”,
    “tss”, “strand”, “counts”;

Other important inputs are:

-   `learning_methods`, a character to specify the method used to obtain
    the adjustment distance. The input has to be either “weighted_mean”
    or “median”. The default is set to “weighted_mean”.
-   `ncore`, an integer specifying the number of cores used for
    computation. Defaults to 1.

An example code for Sample 1 is shown below.

``` r
NearSite_clsuter_Sample1 <- NearSite_clsuter_Sample1[,c("chr","start","end","strand")]
colnames(NearSite_clsuter_Sample1) <- c("seqnames","start","end","strand")

TSS_clsuters_Sample1 <- adjustTSS(anno_path= "example_genes.gtf",
                                  clusters = NearSite_clsuter_Sample1,
                                  mappedTSS =  mappedTSS_Sample1,
                                  learning_methods = "weighted_mean",
                                  ncore = 1)
```

    ## [1] "Start learning the adjustment distance..."
    ## [1] "The learnt adjustment distance is 177 bp."
    ## [1] "Start adjusting near-site clusters regions..."
    ## [1] "Done!"

`adjustTSS` produce a `list` as output, which includes two elements:

-   “learnt_adj_dist”, an integer specifying the learnt adjustment
    distances;

-   “adj_TSS_clusters”, a data.frame for the adjusted TSS clusters. It
    has these columns: “seqnames”, “tss5prime”, “width”, “strand”,
    “org_start”, “org_end”.

    -   seqnames: the chromosome where the TSS clusters are located;
    -   tss5prime: the location for the 5’ end of the adjusted TSS
        clusters;
    -   width: the lengths of TSS clusters;
    -   org_start: the corresponding start location of the near-site
        regions before adjustment;
    -   org_end: the corresponding end location of the near-site regions
        before adjustment.

The example output form `adjustTSS` is shown below:

``` r
TSS_clusters_Sample1$learnt_adj_dist
```

    ## [1] 177

``` r
head(TSS_clusters_Sample1$adj_TSS_clusters)
```

    ##   seqnames tss5prime width strand org_start  org_end
    ## 1     chr6  26235095   251      -  26234668 26234918
    ## 2    chr21  44353551   112      +  44353728 44353839
    ## 3    chr21  33468585    76      -  33467048 33467123
    ## 4    chr21  33479133   137      -  33468789 33468925
    ## 5    chr21  36156830    65      +  36164714 36164778
    ## 6    chr21  17817728    78      -  17797038 17797115

# Merging TSS clusters for multiple samples

Due to technical effects during the sequencing or mapping procedures,
the TSS clusters predicted on each single sample might be a few base
pairs different, even if they might refer to the exact same promoter (or
TSS cluster). Thus, merging TSS clusters from multiple samples to obtain
a unified TSS clusters is necessary for downstream multiple sample
analysis.

TSS cluster merging is achieved by function `mergeTSS`. The major
parameters of `mergeTSS` are

-   `unmerged_TSS_cluster_list`, a `list` of `data.frames`. Every single
    `data.frame` within this list is the unmerged TSS cluster
    predictions for a sample. For the ***single-end*** data, each
    `data.frame` should contain columns listed below with the exact
    column names:

    -   seqnames: the chromosome where the TSS clusters are located;
    -   tss5prime: the location for the 5’ end of the adjusted TSS
        clusters;
    -   width: the lengths of TSS clusters;
    -   org_start: the corresponding start location of the near-site
        regions before adjustment;
    -   org_end: the corresponding end location of the near-site regions
        before adjustment.

Within the `mergeTSS` function, we also need to pay attention to these
parameters:

-   `if_paired`, TRUE/FALSE and specifies if the data is paired-end
    (TRUE) or single-end (FALSE). The default is TRUE;
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

In the following example, we already have the unmerged TSS clusters
predicted on the chromosome 21 of the 6 samples separately. The unmerged
TSS clusters are stored in an object named `unmerged_TSS_clusters`,
which is a `list` object. Within this `list`, the TSS cluster
predictions are stored in 6 different `data.frame`. Each `data.frame` is
corresponding to a sample.

``` r
# read in the list of unmerged TSS clusters for 6 samples
unmerged_TSS_clusters <- readRDS("unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample 1
head(unmerged_TSS_clusters$Sample1)
```

    ##      seqnames tss5prime width strand org_start  org_end
    ## 3313    chr21  44353552   112      +  44353728 44353839
    ## 3316    chr21  33468584    76      -  33467048 33467123
    ## 3317    chr21  33479132   137      -  33468789 33468925
    ## 3318    chr21  36156831    65      +  36164714 36164778
    ## 3784    chr21  17817727    78      -  17797038 17797115
    ## 3785    chr21  17818985    83      -  17818194 17818276

An example for merging TSS clusters is shown below.

``` r
# perform TSS merging
mergedTSS_clusters <- mergeTSS(unmerged_TSS_cluster_list = unmerged_TSS_clusters,
                               if_paired = FALSE,
                               ncore = 1)
```

For single-end data, the `mergeTSS` returns a list, which has two
elements. The first element is “merged_TSS_cluster_table”, which is a
`data.frame` for the merged TSS clusters across all the samples.
“merged_TSS_cluster_table” has these columns:

-   “seqnames”, the chromosome where the TSS clusters are located;
-   “tss5prime”, the location for the 5’ end of the adjusted TSS
    clusters;
-   “width”, the width of the TSS clusters;
-   “strand”, the strand where the TSS clusters are on.

The other element is a `list` of `data.frame` named “cluster_to_region”.
Each of these `data.frame` is corresponding to a sample and is required
for the TSS quantification step below. An example for the merged TSS
clusters is shown below.

``` r
# example for merged_TSS_cluster_table
head(mergedTSS_clusters$merged_TSS_cluster_table)
```

    ##   seqnames tss5prime width strand
    ## 1    chr21   7749230    23      +
    ## 2    chr21   7749253    12      +
    ## 3    chr21   7749265    32      +
    ## 4    chr21   7749297    23      +
    ## 5    chr21  15729935    97      +
    ## 6    chr21  25561967   144      +

``` r
# example for cluster_to_region
head(mergedTSS_clusters$cluster_to_region$Sample1)
```

    ##   seqnames tss5prime width strand org_start  org_end
    ## 1    chr21  44353552   112      +  44353728 44353839
    ## 2    chr21  36156831     3      +  36164714 36164716
    ## 3    chr21  36156834    25      +  36164717 36164741
    ## 4    chr21  36156859    12      +  36164742 36164753
    ## 5    chr21  36156871    25      +  36164754 36164778
    ## 6    chr21  29288011   120      +  29299477 29299596

# Qauntifing the expression for TSS clusters

After obtaining the merged TSS clusters, we need to quantify the
single-cell TSS cluster expression (counts) sample by sample, which is
achieved by function `quantifyTSS`.

The must-have input arguments for `quantifyTSS` are

-   `anno_path`, the path to the genome annotation file, which should be
    in the **.gtf** format;
-   `bam_path`, the path to the aligned **.bam** file of the sample.
    Noting that the corresponding **.bai** file should be stored under
    the same directory;
-   `tss_clusters`, a `data.frame` specifies the TSS clusters to be
    quantified. single-end data, these column should be included:
    seqnames, tss5prime, width, strand, org_start, org_end;
-   `cell_meta`, a data.frame specifies the meta information for each
    cell. “barcode” and “sampleID” must be included as columns.
    “barcode” specifies the barcodes for each of the cells to be
    quantified in this sample; “sampleID” is a unique ID for each
    sample. To make downstream analysis easier, other related variables
    are also suggested to be included in this `data.frame` as well, such
    as cell types or the sample’s demographic information (age, gender,
    etc.).

These are the other parameters that also control the behaviors of
`quantifyTSS`:

-   `gene_of_interest`, a vector of characters and specifies the genes
    for which the TSS quantification should be performed. The default is
    set to `NULL`, which means all the genes in the **.gtf** file are
    considered. The input gene names should be compatible to the
    **.gtf** file;
-   `read_number`, an integer specifying the minim number of reads that
    should be assigned to a valid TSS clusters within this sample. This
    is used to filter out lowly expressed TSS clusters. Defaults to 50.
-   `reads_percentage`, a percentage specifying the minim percentage of
    reads on a gene that should be assigned to a valid TSS clusters
    within this sample. This is used to filter out lowly expressed TSS
    clusters. Defaults to 0.05.
-   `if_paired`, TRUE/FALSE and specifies if the data is paired-end
    (TRUE) or single-end (FALSE). The default is TRUE;
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

In the following example, we use the `cluster_to_region` (which is the
output from `mergeTSS`) as the input `tss_clusters` to be quantified.
Since the TSS cluster quantification is repetitive for all the samples,
we only show an example for “Sample 1”. The cell meta data for Sample 1
is stored in an object named `sample1_meta`.

``` r
# read in the cell_meta for Sample1
sample1_meta <- readRDS("Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```

    ##              barcode     cell_type condition sampleID
    ## 1 AAACCTGAGCCTATGT-1  Effector CD8   Healthy  Sample1
    ## 2 AAACCTGAGCTGTTCA-1    Neutrophil   Healthy  Sample1
    ## 3 AAACCTGAGCTTTGGT-1    Neutrophil   Healthy  Sample1
    ## 4 AAACCTGCACGTCAGC-1  Effector CD8   Healthy  Sample1
    ## 5 AAACCTGTCTGGCGAC-1 Gamma-Delta T   Healthy  Sample1
    ## 6 AAACGGGAGATGTAAC-1    Neutrophil   Healthy  Sample1

An example for quantifying TSS clusters for Sample1 is shown below.

``` r
# Quantify TSS clusters' expression for Sample1
TSS_clusters_Sample1 <- mergedTSS_clusters$cluster_to_region$Sample1
example_genes <- c("ENSG00000142185","ENSG00000142188",
                   "ENSG00000142197","ENSG00000154642")

Sample1_quantified <- quantifyTSS(anno_path = "example_genes.gtf",
                                  bam_path = "Sample1_sorted.bam",
                                  tss_clusters = TSS_clusters_Sample1,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = FALSE,
                                  ncore = 1)
```

    ## [1] "Start quantifing 13 clusters on 4 genes"
    ## [1] "Counting reads finished!"

`quantifyTSS` outputs a list which contains two objects. 1)
`TSS_cluster_counts`, a `data.table` for the expression (counts) of each
TSS clusters at cell level. 2) `Column_meta`, a `data.frame` containing
the meta information for each of the columns (cells) in
`TSS_cluster_counts`. The columns in TSS_cluster_counts and the rows in
`Column_meta` have one on one correspondence.

In the `TSS_cluster_counts`,each TSS clusters being quantified is given
a unique name, which is coded as \[chromosome\]:\[gene\]:\[the 5’
location of TSS clusters\]:\[width\]:\[strand\]. For example,
chr21:ENSG00000141956:41879301:21:-.

``` r
# example of the TSS quantification output for Sample 1

## TSS cluster counts
head(Sample1_quantified$TSS_cluster_counts[,1:3])
```

    ##                            TSS_clusters Sample1_AAACCTGAGCCTATGT-1
    ##                                  <char>                      <int>
    ## 1: chr21:ENSG00000142185:44353552:112:+                          0
    ## 2:  chr21:ENSG00000142188:33468532:24:-                          0
    ## 3:  chr21:ENSG00000142188:33468542:10:-                          0
    ## 4:  chr21:ENSG00000142188:33468577:35:-                          0
    ## 5:   chr21:ENSG00000142188:33468584:7:-                          0
    ## 6: chr21:ENSG00000142188:33479125:130:-                          0
    ##    Sample1_AAACCTGAGCTGTTCA-1
    ##                         <int>
    ## 1:                          0
    ## 2:                          0
    ## 3:                          0
    ## 4:                          0
    ## 5:                          0
    ## 6:                          0

``` r
## column meta for TSS cluster counts
head(Sample1_quantified$Column_meta)
```

    ##                      barcode     cell_type condition sampleID
    ## 1 Sample1_AAACCTGAGCCTATGT-1  Effector CD8   Healthy  Sample1
    ## 2 Sample1_AAACCTGAGCTGTTCA-1    Neutrophil   Healthy  Sample1
    ## 3 Sample1_AAACCTGAGCTTTGGT-1    Neutrophil   Healthy  Sample1
    ## 4 Sample1_AAACCTGCACGTCAGC-1  Effector CD8   Healthy  Sample1
    ## 5 Sample1_AAACCTGTCTGGCGAC-1 Gamma-Delta T   Healthy  Sample1
    ## 6 Sample1_AAACGGGAGATGTAAC-1    Neutrophil   Healthy  Sample1

# Differential TSS usage (DU) test

In the **scTSS** package, we implemented a binomial generalized linear
mixed model (GLMM) to test the differential TSS usage between conditions
while controlling the sample level variability. For more detailed
formulation, please check our paper.

Suppose we have quantified all the 6 samples beforehand and the
quantification output can be found under the folder
`TSS_quantification_outs` within the example data folder.

In the chunk below, we read in the quantification results for the 5
example samples and store them in an object called
`Quantified_TSS_clusters`, which is a `list`.

``` r
# read in quantification results
Sample1 <- readRDS("TSS_quantification_outs/Sample1_quantification_out.rds")
Sample2 <- readRDS("TSS_quantification_outs/Sample2_quantification_out.rds")
Sample3 <- readRDS("TSS_quantification_outs/Sample3_quantification_out.rds")
Sample4 <- readRDS("TSS_quantification_outs/Sample4_quantification_out.rds")
Sample5 <- readRDS("TSS_quantification_outs/Sample5_quantification_out.rds")
Sample6 <- readRDS("TSS_quantification_outs/Sample6_quantification_out.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5,
                                Sample6 = Sample6)
```

## Preparation

Before running the DU test, we need to prepare the quantification
output. The preparation usually consists of two parts:

-   Prepare the joint TSS cluster count matrix (of `matrix` format in R)
    for multiple samples, which can usually be broken down into these
    steps:

    -   Merge TSS cluster count matrices for multiple samples;
    -   Remove lowly expressed TSS clusters;
    -   Remove genes that only have only one TSS clusters (If a gene has
        only one TSS clusters expressed, the usage of this TSS cluster
        will remain 100% between cell types or conditions no matter
        what).

-   Prepare the column (cell) meta data (of `data.frame` format) that is
    corresponding to the joint TSS cluster count matrix.

To make the preparation easier, we include a function named
`SetMatrixNameSame` to provide an all-in-one solution.
`SetMatrixNameSame` has these important argument for input:

-   `Quantified_TSS_list`, a `list` of the outputs from the
    `quantifyTSS` function. Each element of the list is a single output.

There are other argument to control the behavior of `SetMatrixNameSame`:

-   `exp_level`, a percentage. Within every sample (specified by
    “sampleID” in the column meta data), a valid TSS cluster should be
    expressed in more than this percentage of cells. Default is 0,
    indicating any TSS clusters that are not expressed in all sample
    will be removed.

Since we are only interested in the CD8 cells, before we can run
`SetMatrixNameSame`, we need to filter out all other cells for each
sample. The example code is shown below.

``` r
# select only B cells and Activated T cells
for(i in 1:length(quantified_TSS_clusters)){
  temp_sample <- quantified_TSS_clusters[[i]]
  temp_Column_meta <- temp_sample$Column_meta
  temp_TSS_cluster_counts <- temp_sample$TSS_cluster_counts

  ## select the barcode for B cells and Activated T cells
  selected_barcode <- with(temp_Column_meta,
                           barcode[cell_type%in%c("CD8")])

  ## filter both Column_meta and TSS_cluster_counts
  rows_selected <- which(temp_Column_meta$barcode%in%selected_barcode)
  temp_Column_meta <- temp_Column_meta[rows_selected,]

  cols_selected <- c("TSS_clusters",selected_barcode)
  temp_TSS_cluster_counts <- temp_TSS_cluster_counts[ , ..cols_selected]


  temp_sample$Column_meta <- temp_Column_meta
  temp_sample$TSS_cluster_counts <- temp_TSS_cluster_counts

  quantified_TSS_clusters[[i]] <- temp_sample
  }

# running SetMatrixNameSame
DU_input <- SetMatrixNameSame(Quantified_TSS_list = quantified_TSS_clusters,
                              exp_level = 0)
```

    ## [1] "In sample Sample1 15 TSS clusters were delected for low expression."
    ## [1] "In sample Sample2 17 TSS clusters were delected for low expression."
    ## [1] "In sample Sample3 1 TSS clusters were delected for low expression."
    ## [1] "In sample Sample4 2 TSS clusters were delected for low expression."
    ## [1] "In sample Sample5 29 TSS clusters were delected for low expression."
    ## [1] "In sample Sample6 5 TSS clusters were delected for low expression."
    ## [1] "59 TSS clusters were delected for being the single TSS cluster on gene."
    ## [1] "201 TSS clsuters on 35 genes are in the final output."

`SetMatrixNameSame` returns a list containing these two elements:

-   `TSS_count_matrix`, a `data.matrix` object specifying the TSS
    cluster counts matrix ready for DU test;
-   `col_meta`, a column meta `data.frame` compatible with
    `TSS_count_matrix`, which is ready for DU test.

An example for the output is shown below

``` r
# TSS_count_matrix
head(DU_input$TSS_count_matrix[,1:3])
```

    ##                                     Sample1_AAACCTGAGACGCACA-1
    ## chr17:ENSG00000010244:32350080:69:+                          0
    ## chr17:ENSG00000010244:32351570:43:+                          0
    ## chr17:ENSG00000067596:43483928:18:+                          0
    ## chr17:ENSG00000067596:43483946:10:+                          0
    ## chr17:ENSG00000067596:43483956:49:+                          0
    ## chr17:ENSG00000067596:43484019:17:+                          0
    ##                                     Sample1_AAACCTGAGCCTATGT-1
    ## chr17:ENSG00000010244:32350080:69:+                          2
    ## chr17:ENSG00000010244:32351570:43:+                          0
    ## chr17:ENSG00000067596:43483928:18:+                          0
    ## chr17:ENSG00000067596:43483946:10:+                          0
    ## chr17:ENSG00000067596:43483956:49:+                          0
    ## chr17:ENSG00000067596:43484019:17:+                          0
    ##                                     Sample1_AAACCTGCACGTCAGC-1
    ## chr17:ENSG00000010244:32350080:69:+                          0
    ## chr17:ENSG00000010244:32351570:43:+                          0
    ## chr17:ENSG00000067596:43483928:18:+                          0
    ## chr17:ENSG00000067596:43483946:10:+                          0
    ## chr17:ENSG00000067596:43483956:49:+                          0
    ## chr17:ENSG00000067596:43484019:17:+                          0

``` r
# col_meta
head(DU_input$col_meta)
```

    ##                      barcode cell_type condition sampleID
    ## 1 Sample1_AAACCTGAGACGCACA-1       CD8   Healthy  Sample1
    ## 2 Sample1_AAACCTGAGCCTATGT-1       CD8   Healthy  Sample1
    ## 3 Sample1_AAACCTGCACGTCAGC-1       CD8   Healthy  Sample1
    ## 4 Sample1_AAACGGGCAGTATCTG-1       CD8   Healthy  Sample1
    ## 5 Sample1_AAACGGGGTAAGTTCC-1       CD8   Healthy  Sample1
    ## 6 Sample1_AAAGATGTCACATACG-1       CD8   Healthy  Sample1

#### DU test

After we have obtained the prepared TSS cluster count matrix and the
column meta data, we can conduct DU test. We wrapped the DU test
functionality into function `DUtest`. This function has these must-have
arguments:

-   `mat`, `data.matrix` for the count matrix of TSS clusters. The rows
    are TSS clusters and the columns are cells;
-   `col_meta`, a data.frame containing the column meta information for
    “mat”. It has to contain at least these columns: “barcode”,
    “sampleID”, “condition”.

In the example data, our goal is to test the differential TSS cluster
usage for CD8 cells between the healthy and leukemia groups. Thus, the
“condition” in this example is if the individual is healthy.

Other important arguments are:

-   `agg_level`, a string to specify the DU test model (“bulk” or
    “cell”). “cell” means the DU test is conducted at single-cell level,
    “bulk” means the DU test is conducted at the pseudo-bulk level. The
    default is “bulk.”
-   `full_model`, the `formula` for the full model. The default is
    cbind(TSS_counts,gene_counts - TSS_counts) ~ condition +
    (1\|sampleID).
-   `base_model`, the `formula` for the base model. The default is
    cbind(TSS_counts,gene_counts - TSS_counts) ~ (1\|sampleID).
-   `ncore`, an integer and specifies the number of cores used for
    parallel computation. The default is 1.

The example code is shown below.

``` r
outs <- DUtest(mat = DU_input$TSS_count_matrix,
               col_meta = DU_input$col_meta,
               agg_level = "bulk",
               full_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID),
               base_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID),
               ncore = 1)
```

    ## [1] "Start running DU test."
    ## [1] "Done!"

The `DUtest` outputs a `data.frame` containing the *p*-values and other
statistics:

-   “gene_exp_level”, the number of cells having the gene expressed;
-   “TSS_exp_level”, the number of cells having the TSS cluster
    expressed;
-   “max_usage_con”, the condition that has the maximum average TSS
    usage;
-   “max_usage”, the average TSS cluster usage for the condition that
    has the maximum average TSS usage.
-   “min_usage_con”, the condition that has the minimum average TSS
    usage.
-   “min_usage”, the average TSS usage for the condition that has the
    minimum average TSS usage.
-   “pval_adj”, the adjusted *p*-values by Benjamini-Hochberg procedure.

A part of the result is shown below.

``` r
head(outs)
```

    ##                             TSS_names gene_exp_level TSS_exp_level       pval
    ## 1 chr17:ENSG00000010244:32350080:69:+           2354          2171 0.24435647
    ## 2 chr17:ENSG00000010244:32351570:43:+           2354          1238 0.24435647
    ## 3 chr17:ENSG00000067596:43483928:18:+            670           288 0.22562859
    ## 4 chr17:ENSG00000067596:43483946:10:+            670           196 0.93587187
    ## 5 chr17:ENSG00000067596:43483956:49:+            670           573 0.69780500
    ## 6 chr17:ENSG00000067596:43484019:17:+            670           285 0.09595541
    ##   max_usage_con  max_usage min_usage_con  min_usage  pval_adj
    ## 1       Healthy 0.77709115        Cancer 0.77544017 0.5246477
    ## 2        Cancer 0.22455983       Healthy 0.22290885 0.5246477
    ## 3       Healthy 0.16842105        Cancer 0.15267176 0.5211502
    ## 4        Cancer 0.09564436       Healthy 0.09554656 0.9514594
    ## 5       Healthy 0.60404858        Cancer 0.59901212 0.7836887
    ## 6        Cancer 0.15267176       Healthy 0.13198381 0.4120438
