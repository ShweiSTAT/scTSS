---
title: "scTSS Tutorial (Paired-end)"
output:
  md_document:
    variant: markdown_github
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

scTSS is a package that can leverage the 5' single-cell RNA-seq data to study the transcription start site (TSS) at single-cell resolution. scTSS comprises of two main stages, TSS prediction and differential TSS usage (DU) test for TSSs across two or multiple conditions or cell types.

To download scTSS from github and load package, please follow:

```{r eval=FALSE}
devtools::install_github("https://github.com/ShweiSTAT/scTSS")
library(scTSS)
```

```{r echo=FALSE, eval=TRUE}
library(scTSS)
```

The example data for this tutorial can be downloaded from this [link](https://www.dropbox.com/scl/fo/6m2xepe4wrleq5yl59w3h/AP8qu3d_1FVUKuHvxMrO9pg?rlkey=5u3h6qfsw4894x3z78ihapuad&st=g7yds674&dl=0). In this example, we have 5 samples (blood from 5 different human) with TSS clusters predicted based on paired-end 5' single-cell RNA-seq data. Our final goal is to detect differential TSS cluster usage between the B and Activated T cells across the 5 samples.

# Preprocessing

For the paired-end data, the preprocessing starts with the raw reads (**.fastq** files) from 5' single-cell RNA-seq experiments. The reads should be aligned to reference genome by an alignment tool for single-cell RNA sequencing data. We assume this alignment is performed sample by sample. For example, for the reads generated by 10x Genomics 5' Gene Expression assay, we use Cell Ranger to perform alignment for each one of the samples. At the end of the alignment step, we obtain the aligned **.bam** file and the corresponding **.bai** file for each sample.

# Predicting TSS clusters for a sample

The paired-end 5' single-cell RNA-seq data contains both read 1 and read 2. The read 1 contains the direct information of the transcription start site (TSS), thus we call the paired-end data as "on-site" data. Most of the already available TSS analysis tools are capable of predicting TSS clusters based on the mapped genomic positions of the 5' of the read 1. Thus, scTSS will rely on the existing tools to predict TSS clusters for each sample. 
![Paired-end data](/Users/shiweifu/Desktop/scTSS/vignettes/pairedEndDemo.pdf)

After the preprocessing step, we need to use the **.bam** files to obtain predictions for TSS clusters by a bioinformatics tool compatible with. We recommend using SCAFE. Please refer to this [link](https://github.com/chung-lab/SCAFE) for details. After running SCAFE (or any other TSS prediction tools of choice), we should obtain a prediction of TSS clusters for each sample. As for SCAFE, the predicted TSS clusters are stored in a **.bed** file, please refer to this [file](https://www.dropbox.com/scl/fi/hhri3bfxc1tt35jz9ag52/example_SCAFE_clusters.bed?rlkey=u6ztyzfzxmch67eq6ih0qdpa1&st=w1x3l88t&dl=0) as an example. 

No matter what TSS cluster prediction tools used, we need to at least obtain these pieces of information for each sample:

    - seqnames: the chromosome where the TSS cluster located;
    - start: the start location (on genome) of the TSS cluster;
    - end: the end location (on genome) of the TSS cluster;
    - strand: the strand that the TSS cluster is on.

For the SCAFE output, these information are stored in columns "V1" (seqnames), "V2" (start), "V3" (end) and "V5" (strand). 
```{r echo=TRUE, eval=FALSE}
TSS_clsuterEg <- read.delim("example_SCAFE_clusters.bed",
                             header = 0)
head(TSS_clsuterEg)
```

```{r echo=FALSE, eval=TRUE}
TSS_clsuterEg <- read.delim("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/example_SCAFE_clusters.bed",
                             header = 0)
head(TSS_clsuterEg)
```

# Merging TSS clusters for multiple samples

Due to technical effects during the sequencing or mapping procedures, the TSS clusters predicted on each single sample might be a few base pairs different, even if they might refer to the exact same promoter (or TSS cluster). Thus, merging TSS clusters from multiple samples to obtain a unified TSS clusters is necessary for downstream multiple sample analysis.

TSS cluster merging is achieved by function `mergeTSS`. The major parameter of `mergeTSS` is

  + `unmerged_TSS_cluster_list`, a `list` of `data.frames`. Every single `data.frame` within this list is the unmerged TSS cluster predictions for a sample. Each `data.frame` should contain columns listed below with the exact column names:
  
    - seqnames: the chromosome where the TSS cluster located;
    - start: the start location (on genome) of the TSS cluster;
    - end: the end location (on genome) of the TSS cluster;
    - strand: the strand that the TSS cluster is on.
    
Within the `mergeTSS` function, we also need to pay attention to these parameters:
  
  + `if_paired`, TRUE/FALSE and specifies if the data is paired-end (TRUE) or single-end (FALSE). The default is TRUE;
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.

In the following example, we have the unmerged TSS clusters predicted on the 5 samples separately. The unmerged TSS clusters are stored in an object named `unmerged_TSS_clusters`, which is a `list` object. Within this `list`, the TSS cluster predictions are stored in 5 different `data.frame`. Each `data.frame` is corresponding to a sample.

```{r echo = TRUE, eval=FALSE}
# read in the list of unmerged TSS clusters for 5 samples
unmerged_TSS_clusters <- readRDS("unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample1
head(unmerged_TSS_clusters$Sample1)
```

```{r echo=FALSE, eval=TRUE}
# read in the list of unmerged TSS clusters for 5 samples
unmerged_TSS_clusters <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample1
head(unmerged_TSS_clusters$Sample1)
```
An example for merging TSS clusters is shown below.

```{r eval= TRUE}
# perform TSS merging
mergedTSS_clusters <- mergeTSS(unmerged_TSS_cluster_list = unmerged_TSS_clusters,
                               if_paired = TRUE,
                               ncore = 1)
```

For paired-end data, the `mergeTSS` returns a single `data.frame` for the merged TSS clusters across all the samples.

```{r eval= TRUE}
# example for merged TSS clusters
head(mergedTSS_clusters)
```

# Qauntifing the expression for TSS clusters

After obtaining the merged TSS clusters, we need to quantify the single-cell TSS cluster expression (counts) sample by sample, which is achieved by function `quantifyTSS`. 

The must-have input arguments for `quantifyTSS` are 

  + `anno_path`, the path to the genome annotation file, which should be in the **.gtf** format;
  + `bam_path`, the path to the aligned **.bam** file of the sample. Noting that the corresponding **.bai** file should be stored under the same directory;
  + `tss_clusters`, a `data.frame` specifies the TSS clusters to be quantified. For paired-end data, these columns should be included: seqnames, start, end and strand;
  + `cell_meta`, a data.frame specifies the meta information for each cell. "barcode" and "sampleID" must be included as columns. "barcode" specifies the barcodes for each of the cells to be quantified in this sample; "sampleID" is a unique ID for each sample. To make downstream analysis easier, other related variables are also suggested to be included in this `data.frame` as well, such as cell types or the sample's demographic information (age, gender, etc.). 
  
These are the other parameters that also control the behaviors of `quantifyTSS`:

  + `gene_of_interest`, a vector of characters and specifies the genes for which the TSS quantification should be performed. The default is set to `NULL`, which means all the genes in the **.gtf** file are considered. The input gene names should be compatible to the **.gtf** file;
  + `read_number`, an integer specifying the minim number of reads that should be assigned to a valid TSS clusters within this sample. This is used to filter out lowly expressed TSS clusters. Defaults to 50.
  + `reads_percentage`, a percentage specifying the minim percentage of reads on a gene that should be assigned to a valid TSS clusters within this sample. This is used to filter out lowly expressed TSS clusters. Defaults to 0.05.
  + `if_paired`, TRUE/FALSE and specifies if the data is paired-end (TRUE) or single-end (FALSE). The default is TRUE;
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.

In the following example, we use the merged TSS clusters from the 5 samples as the input `tss_clusters` to be quantified. Since the TSS cluster quantification is repetitive for all the 5 samples, we only show an example for "Sample1". The cell meta data for Sample1 is stored in an object named `sample1_meta`.

```{r echo=TRUE, eval=FALSE}
# read in the cell_meta for Sample1
sample1_meta <- readRDS("Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```

```{r echo=FALSE, eval=TRUE}
# read in the cell_meta for Sample1
sample1_meta <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```
An example for quantifying TSS clusters for Sample1 is shown below.

```{r echo=TRUE, eval=FALSE}
# Quantify TSS clusters' expression for Sample1

example_genes <- c("ENSG00000141956","ENSG00000141959",
                   "ENSG00000142156","ENSG00000142166",
                   "ENSG00000142168","ENSG00000142173",
                   "ENSG00000142178","ENSG00000142185",
                   "ENSG00000142188","ENSG00000142192",
                   "ENSG00000142197","ENSG00000142207",
                   "ENSG00000154639","ENSG00000154640",
                   "ENSG00000154642")


Sample1_quantified <- quantifyTSS(anno_path = "example.gtf",
                                  bam_path = "Sample1_sorted.bam",
                                  tss_clusters = mergedTSS_clusters,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = TRUE,
                                  ncore = 1 )
```
```{r echo=FALSE, eval=TRUE, warning=FALSE, message=FALSE}
# Quantify TSS clusters' expression for Sample1

example_genes <- c("ENSG00000141956","ENSG00000141959",
                   "ENSG00000142156","ENSG00000142166",
                   "ENSG00000142168","ENSG00000142173",
                   "ENSG00000142178","ENSG00000142185",
                   "ENSG00000142188","ENSG00000142192",
                   "ENSG00000142197","ENSG00000142207",
                   "ENSG00000154639","ENSG00000154640",
                   "ENSG00000154642")

Sample1_quantified <- quantifyTSS(anno_path = "/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/example.gtf",
                                  bam_path = "/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/Sample1_sorted.bam",
                                  tss_clusters = mergedTSS_clusters,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = TRUE,
                                  ncore = 1 )
```


`quantifyTSS` outputs a list which contains two objects. 1) `TSS_cluster_counts`, a `data.table` for the expression (counts) of each TSS clusters at cell level. 2) `Column_meta`, a ` data.frame` containing the meta information for each of the columns (cells) in `TSS_cluster_counts`. The columns in TSS_cluster_counts and the rows in `Column_meta` have one on one correspondence.

In the `TSS_cluster_counts`,each TSS clusters being quantified is given a unique name, which is coded as [chromosome]:[gene]:[start]:[end]:[strand]. For example chr21:ENSG00000141956:41879301:41879351:-.

```{r eval=TRUE}
# example of the TSS quantification output for Sample1

## TSS cluster counts
head(Sample1_quantified$TSS_clsuter_counts[,1:3])

## column meta for TSS cluster counts
head(Sample1_quantified$Column_meta)
```

# Differential TSS usage (DU) test

In the **scTSS** package, we implemented a binomial generalized linear mixed model (GLMM) to test the differential TSS usage between conditions while controlling the sample level variability. For more detailed formulation, please check our paper.

Suppose we have quantified all the 5 samples beforehand and the quantification output can be found under the folder `TSS_quantification_outs` within the example data folder.

In the chunk below, we read in the quantification results for the 5 example samples and store them in an object called `Quantified_TSS_clusters`, which is a `list`.

```{r eval=FALSE}
# read in quantification results
Sample1 <- readRDS("TSS_quantification_outs/Sample1_quant_outs.rds")
Sample2 <- readRDS("TSS_quantification_outs/Sample2_quant_outs.rds")
Sample3 <- readRDS("TSS_quantification_outs/Sample3_quant_outs.rds")
Sample4 <- readRDS("TSS_quantification_outs/Sample4_quant_outs.rds")
Sample5 <- readRDS("TSS_quantification_outs/Sample5_quant_outs.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5)
```

```{r echo=FALSE,eval=TRUE}
# read in quantification results
Sample1 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/TSS_quantification_outs/Sample1_quant_outs.rds")
Sample2 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/TSS_quantification_outs/Sample2_quant_outs.rds")
Sample3 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/TSS_quantification_outs/Sample3_quant_outs.rds")
Sample4 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/TSS_quantification_outs/Sample4_quant_outs.rds")
Sample5 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/PairedEnd/make_tutorial_data/TSS_quantification_outs/Sample5_quant_outs.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5)
```

## Preparation 

Before running the DU test, we need to prepare the quantification output. The preparation usually consists of two parts:

  + Prepare the joint TSS cluster count matrix (of `matrix` format in R) for multiple samples, which can usually be broken down into these steps:
  
    - Merge TSS cluster count matrices for multiple samples;
    - Remove lowly expressed TSS clusters;
    - Remove genes that only have only one TSS clusters (If a gene has only one TSS clusters expressed, the usage of this TSS cluster will remain 100% between cell types or conditions no matter what).
  
  + Prepare the column (cell) meta data (of `data.frame` format) that is corresponding to the joint TSS cluster count matrix.
  
To make the preparation easier, we include a function named `SetMatrixNameSame` to provide an all-in-one solution. `SetMatrixNameSame` has these important argument for input:

  + `Quantified_TSS_list`, a `list` of the outputs from the `quantifyTSS` function. Each element of the list is a single output.

There are other argument to control the behavior of `SetMatrixNameSame`:

  + `exp_level`, a percentage. Within every sample (specified by "sampleID" in the column meta data), a valid TSS cluster should be expressed in more than this percentage of cells. Default is 0, indicating any TSS clusters that are not expressed in all sample will be removed.

Since we are only interested in the B cells and Activated T cells, before we can run `SetMatrixNameSame`, we need to filter out all other cells for each sample. The example code is shown below.

```{r eval=TRUE}
# select only B cells and Activated T cells
for(i in 1:length(quantified_TSS_clusters)){
  temp_sample <- quantified_TSS_clusters[[i]]
  temp_Column_meta <- temp_sample$Column_meta
  temp_TSS_cluster_counts <- temp_sample$TSS_cluster_counts
  
  ## select the barcode for B cells and Activated T cells
  selected_barcode <- with(temp_Column_meta,
                           barcode[cell_type%in%c("B","Activated T")])
  
  ## filter both Column_meta and TSS_cluster_counts
  rows_selected <- which(temp_Column_meta$barcode%in%selected_barcode)
  temp_Column_meta <- temp_Column_meta[rows_selected,]
  
  cols_selected <- c("TSS_clusters",selected_barcode)
  temp_TSS_cluster_counts <- temp_TSS_cluster_counts[ , ..cols_selected]

  
  temp_sample$Column_meta <- temp_Column_meta
  temp_sample$TSS_cluster_counts <- temp_TSS_cluster_counts
  
  quantified_TSS_clusters[[i]] <- temp_sample
  }

# running SetMatrixNameSame
DU_input <- SetMatrixNameSame(Quantified_TSS_list = quantified_TSS_clusters,
                              exp_level = 0)

```
`SetMatrixNameSame` returns a list containing these two elements:

  + `TSS_count_matrix`, a `data.matrix` object specifying the TSS cluster counts matrix ready for DU test; 
  + `col_meta`, a column meta `data.frame` compatible with `TSS_count_matrix`, which is ready for DU test.

An example for the output is shown below
```{r eval=TRUE}
# TSS_count_matrix
head(DU_input$TSS_count_matrix[,1:3])

# col_meta
head(DU_input$col_meta)
```

#### DU test

After we have obtained the prepared TSS cluster count matrix and the column meta data, we can conduct DU test. We wrapped the DU test functionality into function `DUtest`. This function has these must-have arguments:

  + `mat`, `data.matrix` for the count matrix of TSS clusters. The rows are TSS clusters and the columns are cells;
  + `col_meta`, a data.frame containing the column meta information for "mat". It has to contain at least these columns: "barcode", "sampleID", "condition".

In the example data, our goal is to test the differential TSS cluster usage between B and Activated T cells among the blood sample from 5 human. Thus, the "condition" in this example is the "cell_type" column. To accommodate this difference, we only need to change the column names for `col_meta` accordingly.

```{r eval=TRUE}
input_mat <- DU_input$TSS_count_matrix
input_colMeta <- DU_input$col_meta
colnames(input_colMeta)[3] <- "condition"

head(input_colMeta)
```

Other important arguments are:

  + `agg_level`, a string to specify the DU test model ("bulk" or "cell"). "cell" means the DU test is conducted at single-cell level, "bulk" means the DU test is conducted at the pseudo-bulk level. The default is "bulk."
  + `full_model`, the `formula` for the full model. The default is cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID).
  + `base_model`, the `formula` for the base model. The default is cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID).
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.
  
The example code is shown below.

```{r eval=TRUE}
outs <- DUtest(mat = input_mat,
               col_meta = input_colMeta,
               agg_level = "bulk",
               full_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID),
               base_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID),
               ncore = 1)
```

The `DUtest` outputs a `data.frame` containing the *p*-values and other statistics:

  + "gene_exp_level", the number of cells having the gene expressed;
  + "TSS_exp_level", the number of cells having the TSS cluster expressed;
  + "max_usage_con", the condition that has the maximum average TSS usage;
  + "max_usage", the average TSS cluster usage for the condition that has the maximum average TSS usage.
  + "min_usage_con", the condition that has the minimum average TSS usage.
  + "min_usage", the average TSS usage for the condition that has the minimum average TSS usage.
  + "pval_adj", the adjusted *p*-values by Benjamini-Hochberg procedure.

A part of the result is shown below.

```{r eval=TRUE}
head(outs)
```
