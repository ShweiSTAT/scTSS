---
title: "scTSS_tutorial_SingleEnd"
output:
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

scTSS is a package that can leverage the 5' single-cell RNA-seq data to study the transcription start site (TSS) at single-cell resolution. scTSS comprises of two main stages, TSS prediction and differential TSS usage (DU) test for TSSs across two or multiple conditions or cell types.

To download scTSS from github and load package, please follow:

```{r eval=FALSE}
devtools::install_github("https://github.com/ShweiSTAT/scTSS")
library(scTSS)
```

```{r echo=FALSE, eval=TRUE}
library(scTSS)
```

The example data for this tutorial can be downloaded from this [link](https://www.dropbox.com/scl/fo/ko6tscaq190382iuoa8vc/AEKkprSmvHYXw4z2tTjIgNQ?rlkey=hbd0ofjxv23pn1rgc6ngyzzi6&st=c6wxxt7f&dl=0). In this example, we have 6 samples (blood from 6 different human). Sample 1, 2 and 3 are healthy individuals, while Sample 4, 5, 6 are patients with a certain type of leukemia. All the blood samples are sequenced by 10X Genomics single-end 5' single-cell RNA-seq. Our final goal is to detect differential TSS cluster usage of CD8 cells between these two groups of samples

# Preprocessing

For the single-end data, the preprocessing starts with the raw reads (**.fastq** files) from 5' single-cell RNA-seq experiments. The reads should be aligned to reference genome by an alignment tool for single-cell RNA sequencing data. We assume this alignment is performed sample by sample. For example, for the reads generated by 10x Genomics 5' Gene Expression assay, we use Cell Ranger to perform alignment for each one of the samples. At the end of the alignment step, we obtain the aligned **.bam** file and the corresponding **.bai** file for each sample.

# Predicting TSS clusters for sample by sample

The single-end 5' single-cell RNA-seq data contains only read 2. The read 2 does not directly capture the location of TSS. However, the position of read 2 follows a relation with the genuine TSS, which is related to the length of cDNA.  


![Single-end data](/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/SingleEndDemo.png)

We call the single-end data as "near-site" data. Most of the already available TSS analysis tools are only compatible with the paired-end (or "on-site") data. Nevertheless, we can utilize the existing tools to generate near-site genomic clusters based on the 5' of read 2, and scTSS incorporates a method to adjust the near-site genomic clusters to approximate the genuine locations of TSS clusters (promoters). Since the TSS cluster prediction is repetitive for every sample, we use a subset of Sample 1 as an example for this section. 

## Generating near-site genomic clusters

After the preprocessing step, we need to use the **.bam** files to predict near-site genomic clusters. We recommend using TSSr. Please refer this [link](https://github.com/Linlab-slu/TSSr) for more detailed information. For TSSr and other TSS analysis tools, they require an input named CTSS (Capped TSS) table or TSS table for TSS clustering. This table is generated by mapping the 5' of Read 1 to the reference genome for paired-end data. Since the single-end data do not have direct TSS information and we need to map the 5' of read 2 onto the genome to generate near-site clusters, we call this table as "mapped TSS table", which usually contains these four columns:

    - seqnames: the chromosome where the TSS cluster located;
    - tss(pos): the mapped location (on genome) of the 5' of Read 2 for single-end data; the mapped location (on genome) of the 5' of Read 1 for paired-end data;
    - strand: the strand of the mapped location on genome;
    - counts: the frequency of reads mapped to this location.

In scTSS, we incorporate a function named `makeMappedTSS` to facilitate near-site genomic clusters prediction and output mapped TSS table based on the aligned **.bam** file. `makeMappedTSS` requires these necessary inputs:

  + `anno_path`, the path to the genome annotation file, which should be in the **.gtf** format;
  + `bam_path`, the path to the **.bam**, which should be stored under the same directory as its **.bai** file.
  + `if_paired`, FALSE/TRUE and specifies if we have paired-end (on-site) data (TRUE) or single- end (near-site) data (FALSE). Default set to TRUE.
  
There are other important input that can control the behavior of `makeMappedTSS`:

  + `gene_of_interest`, a vector of characters and specifies the genes for which the `makeMappedTSS` function should be performed. The default is set to `NULL`, which means all the genes in the **.gtf** file are considered. The input gene names should be compatible to the **.gtf** file;
  + `ncore`, an integer specifying the number of cores used for computation. Defaults to 1.

An example code for Sample 1 is shown below:

```{r echo=TRUE,eval=FALSE}
## make mapped TSS table
mappedTSS_Sample1 <- makeMappedTSS(anno_path = "example_genes.gtf",
                                   bam_path = "Sample1_sorted.bam",
                                   gene_of_interest = NULL,
                                   if_paired = FALSE,
                                   ncore = 1)
```

The mapped TSS table is stored in a `data.frame.` An example for mapped TSS table is shown below. 
```{r echo=TRUE,eval=FALSE}
head(mappedTSS_Sample1)
```

```{r echo=FALSE,eval=TRUE}
mappedTSS_Sample1 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/mappedTSS_Sample1.rds")
head(mappedTSS_Sample1)
```

After we have obtained the Mapped TSS table, we can utilize the TSSr or other TSS clustering tools to obtain the near-site clusters. For the near-site clusters, we need to at least obtain these pieces of information for each sample:

    - seqnames: the chromosome where the near-site cluster located;
    - start: the start location (on genome) of the near-site cluster;
    - end: the end location (on genome) of the near-site cluster;
    - strand: the strand that the near-site cluster is on.

For the TSSr output, these information are stored in columns "chr" (seqnames), "start", "end" and "strand." An example output from TSSr is shown below.

```{r eval=FALSE, echo=TRUE}
NearSite_clsuter_Sample1 <- readRDS("TSSr_output_example.rds")
head(NearSite_clsuter_Sample1)
```

```{r eval=TRUE, echo=FALSE}
NearSite_clsuter_Sample1 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSSr_output_example.rds")
head(NearSite_clsuter_Sample1)
```

## Adjusting near-site genomic clusters

After we have obtain the near-site genomic clusters for a sample, we need to adjust them to approximate the genuine locations of TSS clusters. scTSS provides function `adjustTSS` to achieve this goal. `adjustTSS` needs these must-have inputs: 

  + `anno_path`, the path to the genome annotation file, which should be in the **.gtf** format;
  + `clusters`, a `data.frame` containing the near-site clusters to be adjusted. The required columns are "seqnames", "start", "end", "strand";
  + `mappedTSS`, a data.frame containing the mapped TSSs based on the corresponding single-end data. The required columns are "seqnames", "tss", "strand", "counts";

Other important inputs are:

  + `learning_methods`, a character to specify the method used to obtain the adjustment distance. The input has to be either "weighted_mean" or "median". The default is set to "weighted_mean".
  + `ncore`, an integer specifying the number of cores used for computation. Defaults to 1.

An example code for Sample 1 is shown below.

```{r eval=FALSE,echo=TRUE, warning=FALSE,message=FALSE}
NearSite_clsuter_Sample1 <- NearSite_clsuter_Sample1[,c("chr","start","end","strand")]
colnames(NearSite_clsuter_Sample1) <- c("seqnames","start","end","strand")

TSS_clsuters_Sample1 <- adjustTSS(anno_path= "example_genes.gtf",
                                  clusters = NearSite_clsuter_Sample1,
                                  mappedTSS =  mappedTSS_Sample1,
                                  learning_methods = "weighted_mean",
                                  ncore = 1)
```

```{r eval=TRUE,echo=FALSE, warning=FALSE,message=FALSE}
NearSite_clsuter_Sample1 <- NearSite_clsuter_Sample1[,c("chr","start","end","strand")]
colnames(NearSite_clsuter_Sample1) <- c("seqnames","start","end","strand")

TSS_clusters_Sample1 <- adjustTSS(anno_path= "/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/example_genes.gtf",
                                  clusters = NearSite_clsuter_Sample1,
                                  mappedTSS =  mappedTSS_Sample1,
                                  learning_methods = "weighted_mean",
                                  ncore = 1)
```

`adjustTSS` produce a `list` as output, which includes two elements:

  + "learnt_adj_dist", an integer specifying the learnt adjustment distances; 
  
  + "adj_TSS_clusters", a data.frame for the adjusted TSS clusters. It has these columns: "seqnames", "tss5prime", "width", "strand", "org_start", "org_end". 
  
    - seqnames: the chromosome where the TSS clusters are located;
    - tss5prime: the location for the 5' end of the adjusted TSS clusters;
    - width: the lengths of TSS clusters;
    - org_start: the corresponding start location of the near-site regions before adjustment;
    - org_end: the corresponding end location of the near-site regions before adjustment.

The example output form `adjustTSS` is shown below:

```{r echo=TRUE,eval=TRUE}
TSS_clusters_Sample1$learnt_adj_dist

head(TSS_clusters_Sample1$adj_TSS_clusters)
```


# Merging TSS clusters for multiple samples

Due to technical effects during the sequencing or mapping procedures, the TSS clusters predicted on each single sample might be a few base pairs different, even if they might refer to the exact same promoter (or TSS cluster). Thus, merging TSS clusters from multiple samples to obtain a unified TSS clusters is necessary for downstream multiple sample analysis.

TSS cluster merging is achieved by function `mergeTSS`. The major parameters of `mergeTSS` are

  + `unmerged_TSS_cluster_list`, a `list` of `data.frames`. Every single `data.frame` within this list is the unmerged TSS cluster predictions for a sample. For the ***single-end*** data, each `data.frame` should contain columns listed below with the exact column names:
    
    - seqnames: the chromosome where the TSS clusters are located;
    - tss5prime: the location for the 5' end of the adjusted TSS clusters;
    - width: the lengths of TSS clusters;
    - org_start: the corresponding start location of the near-site regions before adjustment;
    - org_end: the corresponding end location of the near-site regions before adjustment.

Within the `mergeTSS` function, we also need to pay attention to these parameters:

  + `if_paired`, TRUE/FALSE and specifies if the data is paired-end (TRUE) or single-end (FALSE). The default is TRUE;
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.

In the following example, we already have the unmerged TSS clusters predicted on the chromosome 21 of the 6 samples separately. The unmerged TSS clusters are stored in an object named `unmerged_TSS_clusters`, which is a `list` object. Within this `list`, the TSS cluster predictions are stored in 6 different `data.frame`. Each `data.frame` is corresponding to a sample.

```{r eval=FALSE,echo=TRUE}
# read in the list of unmerged TSS clusters for 6 samples
unmerged_TSS_clusters <- readRDS("unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample 1
head(unmerged_TSS_clusters$Sample1)
```

```{r eval=TRUE,echo=FALSE}
# read in the list of unmerged TSS clusters for 6 samples
unmerged_TSS_clusters <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/unmerged_TSS_clusters.rds")

# example of unmerged TSS clusters for Sample 1
head(unmerged_TSS_clusters$Sample1)
```

An example for merging TSS clusters is shown below.

```{r eval= TRUE}
# perform TSS merging
mergedTSS_clusters <- mergeTSS(unmerged_TSS_cluster_list = unmerged_TSS_clusters,
                               if_paired = FALSE,
                               ncore = 1)
```

For single-end data, the `mergeTSS` returns a list, which has two elements. The first element is "merged_TSS_cluster_table", which is a `data.frame` for the merged TSS clusters across all the samples. "merged_TSS_cluster_table" has these columns:

  + "seqnames", the chromosome where the TSS clusters are located;
  + "tss5prime", the location for the 5' end of the adjusted TSS clusters;
  + "width", the width of the TSS clusters;
  + "strand", the strand where the TSS clusters are on.

The other element is a `list` of `data.frame` named "cluster_to_region". Each of these `data.frame` is corresponding to a sample and is required for the TSS quantification step below. An example for the merged TSS clusters is shown below.

```{r eval= TRUE}
# example for merged_TSS_cluster_table
head(mergedTSS_clusters$merged_TSS_cluster_table)

# example for cluster_to_region
head(mergedTSS_clusters$cluster_to_region$Sample1)
```

# Qauntifing the expression for TSS clusters

After obtaining the merged TSS clusters, we need to quantify the single-cell TSS cluster expression (counts) sample by sample, which is achieved by function `quantifyTSS`.

The must-have input arguments for `quantifyTSS` are

  + `anno_path`, the path to the genome annotation file, which should be in the **.gtf** format;
  + `bam_path`, the path to the aligned **.bam** file of the sample. Noting that the corresponding **.bai** file should be stored under the same directory;
  + `tss_clusters`, a `data.frame` specifies the TSS clusters to be quantified. single-end data, these column should be included: seqnames, tss5prime, width, strand, org_start, org_end;
  + `cell_meta`, a data.frame specifies the meta information for each cell. "barcode" and "sampleID" must be included as columns. "barcode" specifies the barcodes for each of the cells to be quantified in this sample; "sampleID" is a unique ID for each sample. To make downstream analysis easier, other related variables are also suggested to be included in this `data.frame` as well, such as cell types or the sample's demographic information (age, gender, etc.).

These are the other parameters that also control the behaviors of `quantifyTSS`:

  + `gene_of_interest`, a vector of characters and specifies the genes for which the TSS quantification should be performed. The default is set to `NULL`, which means all the genes in the **.gtf** file are considered. The input gene names should be compatible to the **.gtf** file;
  + `read_number`, an integer specifying the minim number of reads that should be assigned to a valid TSS clusters within this sample. This is used to filter out lowly expressed TSS clusters. Defaults to 50.
  + `reads_percentage`, a percentage specifying the minim percentage of reads on a gene that should be assigned to a valid TSS clusters within this sample. This is used to filter out lowly expressed TSS clusters. Defaults to 0.05.
  + `if_paired`, TRUE/FALSE and specifies if the data is paired-end (TRUE) or single-end (FALSE). The default is TRUE;
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.

In the following example, we use the `cluster_to_region` (which is the output from `mergeTSS`) as the input `tss_clusters` to be quantified. Since the TSS cluster quantification is repetitive for all the samples, we only show an example for "Sample 1". The cell meta data for Sample 1 is stored in an object named `sample1_meta`.

```{r eval=FALSE, echo=TRUE}
# read in the cell_meta for Sample1
sample1_meta <- readRDS("Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```

```{r eval=TRUE, echo=FALSE}
# read in the cell_meta for Sample1
sample1_meta <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/Sample1_cellMeta.rds")

# example of the meta data for Sample1
head(sample1_meta)
```

An example for quantifying TSS clusters for Sample1 is shown below.

```{r eval=FALSE, echo=TRUE,warning=FALSE,message=FALSE}
# Quantify TSS clusters' expression for Sample1
TSS_clusters_Sample1 <- mergedTSS_clusters$cluster_to_region$Sample1
example_genes <- c("ENSG00000142185","ENSG00000142188",
                   "ENSG00000142197","ENSG00000154642")

Sample1_quantified <- quantifyTSS(anno_path = "example_genes.gtf",
                                  bam_path = "Sample1_sorted.bam",
                                  tss_clusters = TSS_clusters_Sample1,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = FALSE,
                                  ncore = 1)
```

```{r eval=TRUE, echo=FALSE,warning=FALSE,message=FALSE}
# Quantify TSS clusters' expression for Sample1
TSS_clusters_Sample1 <- mergedTSS_clusters$cluster_to_region$Sample1
example_genes <- c("ENSG00000142185","ENSG00000142188",
                   "ENSG00000142197","ENSG00000154642")

Sample1_quantified <- quantifyTSS(anno_path = "/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/example_genes.gtf",
                                  bam_path = "/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/Sample1_sorted.bam",
                                  tss_clusters = TSS_clusters_Sample1,
                                  cell_meta = sample1_meta,
                                  gene_of_interest = example_genes,
                                  read_number = 20,
                                  reads_percentage = 0.01,
                                  if_paired = FALSE,
                                  ncore = 1)
```


`quantifyTSS` outputs a list which contains two objects. 1) `TSS_cluster_counts`, a `data.table` for the expression (counts) of each TSS clusters at cell level. 2) `Column_meta`, a ` data.frame` containing the meta information for each of the columns (cells) in `TSS_cluster_counts`. The columns in TSS_cluster_counts and the rows in `Column_meta` have one on one correspondence.

In the `TSS_cluster_counts`,each TSS clusters being quantified is given a unique name, which is coded as [chromosome]:[gene]:[the 5' location of TSS clusters]:[width]:[strand]. For example, chr21:ENSG00000141956:41879301:21:-.

```{r eval=TRUE}
# example of the TSS quantification output for Sample 1

## TSS cluster counts
head(Sample1_quantified$TSS_cluster_counts[,1:3])

## column meta for TSS cluster counts
head(Sample1_quantified$Column_meta)
```

# Differential TSS usage (DU) test

In the **scTSS** package, we implemented a binomial generalized linear mixed model (GLMM) to test the differential TSS usage between conditions while controlling the sample level variability. For more detailed formulation, please check our paper.

Suppose we have quantified all the 6 samples beforehand and the quantification output can be found under the folder `TSS_quantification_outs` within the example data folder.

In the chunk below, we read in the quantification results for the 5 example samples and store them in an object called `Quantified_TSS_clusters`, which is a `list`.

```{r eval=FALSE, echo=TRUE}
# read in quantification results
Sample1 <- readRDS("TSS_quantification_outs/Sample1_quantification_out.rds")
Sample2 <- readRDS("TSS_quantification_outs/Sample2_quantification_out.rds")
Sample3 <- readRDS("TSS_quantification_outs/Sample3_quantification_out.rds")
Sample4 <- readRDS("TSS_quantification_outs/Sample4_quantification_out.rds")
Sample5 <- readRDS("TSS_quantification_outs/Sample5_quantification_out.rds")
Sample6 <- readRDS("TSS_quantification_outs/Sample6_quantification_out.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5,
                                Sample6 = Sample6)
```

```{r eval=TRUE, echo=FALSE}
# read in quantification results
Sample1 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample1_quantification_out.rds")
Sample2 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample2_quantification_out.rds")
Sample3 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample3_quantification_out.rds")
Sample4 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample4_quantification_out.rds")
Sample5 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample5_quantification_out.rds")
Sample6 <- readRDS("/Users/shiweifu/Desktop/scTSS_buildingBlocks/example_data/SingleEnd/singleEndData/TSS_quantification_outs/Sample6_quantification_out.rds")

quantified_TSS_clusters <- list(Sample1 = Sample1,
                                Sample2 = Sample2,
                                Sample3 = Sample3,
                                Sample4 = Sample4,
                                Sample5 = Sample5,
                                Sample6 = Sample6)
```

## Preparation

Before running the DU test, we need to prepare the quantification output. The preparation usually consists of two parts:

  + Prepare the joint TSS cluster count matrix (of `matrix` format in R) for multiple samples, which can usually be broken down into these steps:

    - Merge TSS cluster count matrices for multiple samples;
    - Remove lowly expressed TSS clusters;
    - Remove genes that only have only one TSS clusters (If a gene has only one TSS clusters expressed, the usage of this TSS cluster will remain 100% between cell types or conditions no matter what).

  + Prepare the column (cell) meta data (of `data.frame` format) that is corresponding to the joint TSS cluster count matrix.

To make the preparation easier, we include a function named `SetMatrixNameSame` to provide an all-in-one solution. `SetMatrixNameSame` has these important argument for input:

  + `Quantified_TSS_list`, a `list` of the outputs from the `quantifyTSS` function. Each element of the list is a single output.

There are other argument to control the behavior of `SetMatrixNameSame`:

  + `exp_level`, a percentage. Within every sample (specified by "sampleID" in the column meta data), a valid TSS cluster should be expressed in more than this percentage of cells. Default is 0, indicating any TSS clusters that are not expressed in all sample will be removed.

Since we are only interested in the CD8 cells, before we can run `SetMatrixNameSame`, we need to filter out all other cells for each sample. The example code is shown below.

```{r eval=TRUE}
# select only B cells and Activated T cells
for(i in 1:length(quantified_TSS_clusters)){
  temp_sample <- quantified_TSS_clusters[[i]]
  temp_Column_meta <- temp_sample$Column_meta
  temp_TSS_cluster_counts <- temp_sample$TSS_cluster_counts

  ## select the barcode for B cells and Activated T cells
  selected_barcode <- with(temp_Column_meta,
                           barcode[cell_type%in%c("CD8")])

  ## filter both Column_meta and TSS_cluster_counts
  rows_selected <- which(temp_Column_meta$barcode%in%selected_barcode)
  temp_Column_meta <- temp_Column_meta[rows_selected,]

  cols_selected <- c("TSS_clusters",selected_barcode)
  temp_TSS_cluster_counts <- temp_TSS_cluster_counts[ , ..cols_selected]


  temp_sample$Column_meta <- temp_Column_meta
  temp_sample$TSS_cluster_counts <- temp_TSS_cluster_counts

  quantified_TSS_clusters[[i]] <- temp_sample
  }

# running SetMatrixNameSame
DU_input <- SetMatrixNameSame(Quantified_TSS_list = quantified_TSS_clusters,
                              exp_level = 0)

```
`SetMatrixNameSame` returns a list containing these two elements:

  + `TSS_count_matrix`, a `data.matrix` object specifying the TSS cluster counts matrix ready for DU test;
  + `col_meta`, a column meta `data.frame` compatible with `TSS_count_matrix`, which is ready for DU test.

An example for the output is shown below
```{r eval=TRUE}
# TSS_count_matrix
head(DU_input$TSS_count_matrix[,1:3])

# col_meta
head(DU_input$col_meta)
```

#### DU test

After we have obtained the prepared TSS cluster count matrix and the column meta data, we can conduct DU test. We wrapped the DU test functionality into function `DUtest`. This function has these must-have arguments:

  + `mat`, `data.matrix` for the count matrix of TSS clusters. The rows are TSS clusters and the columns are cells;
  + `col_meta`, a data.frame containing the column meta information for "mat". It has to contain at least these columns: "barcode", "sampleID", "condition".

In the example data, our goal is to test the differential TSS cluster usage for CD8 cells between the healthy and leukemia groups. Thus, the "condition" in this example is if the individual is healthy. 

Other important arguments are:

  + `agg_level`, a string to specify the DU test model ("bulk" or "cell"). "cell" means the DU test is conducted at single-cell level, "bulk" means the DU test is conducted at the pseudo-bulk level. The default is "bulk."
  + `full_model`, the `formula` for the full model. The default is cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID).
  + `base_model`, the `formula` for the base model. The default is cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID).
  + `ncore`, an integer and specifies the number of cores used for parallel computation. The default is 1.

The example code is shown below.

```{r eval=TRUE}
outs <- DUtest(mat = DU_input$TSS_count_matrix,
               col_meta = DU_input$col_meta,
               agg_level = "bulk",
               full_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ condition + (1|sampleID),
               base_model = cbind(TSS_counts,gene_counts - TSS_counts) ~ (1|sampleID),
               ncore = 1)
```

The `DUtest` outputs a `data.frame` containing the *p*-values and other statistics:

  + "gene_exp_level", the number of cells having the gene expressed;
  + "TSS_exp_level", the number of cells having the TSS cluster expressed;
  + "max_usage_con", the condition that has the maximum average TSS usage;
  + "max_usage", the average TSS cluster usage for the condition that has the maximum average TSS usage.
  + "min_usage_con", the condition that has the minimum average TSS usage.
  + "min_usage", the average TSS usage for the condition that has the minimum average TSS usage.
  + "pval_adj", the adjusted *p*-values by Benjamini-Hochberg procedure.

A part of the result is shown below.

```{r eval=TRUE}
head(outs)
```
